getcwd()
cwd()
cd
install.packages("depmixS4")
install.packages("ggplot2")
install.packages("tidyverse")
?lm
?norm
?rnorm
rnorm(20, 5, 2)
install.packages(c("MASS", "rlang", "rmarkdown", "xfun", "yaml"))
rnorm(20, 5, 2)
ver
rnorm(20, 1, 2)
cwd
cwd()
getcwd()
getwd()
cd ..
cd .
cd
dir ..
dir
setwd("Desktop")
setwd("C:/Users/nakaz/Desktop/DSBA/TESI/BNP-Net/src_r")
getwd()
library(igraph)
g <- read.graph("celegansneural.gml", format=c("gml"))
test <- read.graph("test.gml", format=c("gml"))
mat <- as_adjacency_matrix(test)
g <- read.graph("karate.gml", format=c("gml"))
g <- read.graph("karate.txt", format=c("gml"))
X <- as_adjacency_matrix(test)
X
X <- as_adjacency_matrix(g)
X
len(X)
lenght(X)
len?
'len'
?lenght
?length
'?length
??length
sda
x = 1
x
N = length(X)
N
X
X.shape
shape(x)
dim(x)
dim(X)
dim(X)[0]
typeof(dim(X))
dim(X)
dim(X)[1]
nrow(X)
N = nrow(X)
N
c(1:N)
z <- vector(mode="character", length=10)
z
dim(z)
z <- integer(10)
z
z <- integer(10)+1
z
#Initialize assignment vector (1 component)
z <- integer(N)+1
z
dim(z)
typeof(z)
#Initialize assignment vector (1 component)
z <- rep(1, N)
z
dim(z)
length(z)
#Initialize assignment vector (1 component)
z <- vec2mat(rep(1, N))
Z =
?vec2mat
??vec2mat
vec2mat <- function(clust_lab){
# in: vector clust_lab of length V s.t. clust_lab[v]=h if node v is in cluster h
# out: binary VxH matrix M s.t. M[v,h]=1{node v is in cluster h}
V <- length(clust_lab)
H <- max(clust_lab)
M <- matrix(0,V,H)
for (v in 1:V){
M[v,clust_lab[v]] <- 1
}
return(M)
}
#Initialize assignment vector (1 component)
z <- vec2mat(rep(1, N))
z
dim(z)
#Initialize assignment vector (1 component)
z <- matrix(1, N, 1)
z
length(z)
dim(z)
n = 1
X_ = [-n, ]
X_ <= X[-n , ]
X_ <- X[-n , ]
X_
X[:5,:5]
typeof(X)
matrix(X)
matrix(X, nrow(X), ncol(X))
X <- matrix(X, nrow(X), ncol(X))
dim(X)
X[:5,:5]
X[1:5,1:5]
X <- as_adjacency_matrix(g)
X[1:5,1:5]
sum(X[1:5,1:5])
sum(X[1:5,1:5], 1)
#X <- matrix(X, nrow(X), ncol(X))
X <- X[1:5,1:5]
N = nrow(X)
X_ <- X[-n , ]
X_
n
X_ <- X[-n , -n]
X_
X
K <- ncol(z)
K
#Initialize assignment vector (1 component)
z <- matrix(1, N, 1)
z
z[-n,
]
z[-n,]
m = colSums(z[-n,])
if (K>1){m = colSums(z[-n,])} else {m = sum(z[-n])}
m
?crossprod
repmat(m, K, 1)
package(pracma)
install.packages(pracma)
install.packages('pracma')
library(pracma)
repmat(m, K, 1)
z[-n,]
z[-n,].T
z[-n,].t
z.t <- t(z)
z.t
z[-n,]
t(z[-n,])
t(t(z[-n,]))
z
dot(z[-n,], X_)
z[-n,]
X_
z[-n,]
t(z[-n,])
z[-n,]
dot(z[-n,], X_)
dot(z[-n,], X_)
X_
z[-n,]
z[-n,] %*% X_
z[-n,] %*% X_ %*% z[-n,]
z[-n,] %*% X_ %*% z[-n,] -
?diag
X_@z[nn,:]
X_%*%z[nn,:]
X_ %*% z[nn,:]
X_ %*% z[-n,]
X_ %*% z[-n,] * z[-n,]
diag(X_ %*% z[-n,] * z[-n,])
(X_ %*% z[-n,] * z[-n,]) / 2
t((X_ %*% z[-n,] * z[-n,]) / 2)
(X_ %*% z[-n,] * z[-n,]) / 2)
((X_ %*% z[-n,] * z[-n,]) / 2))
(X_ %*% z[-n,] * z[-n,]) / 2
c(X_ %*% z[-n,] * z[-n,]) / 2)
c((X_ %*% z[-n,] * z[-n,]) / 2)
X <- as_adjacency_matrix(g)
X <- matrix(X, nrow(X), ncol(X))
X <- X[1:5,1:5]
N = nrow(X)
#Initialize assignment vector (1 component)
z <- matrix(1, N, 1)
n = 1
n = 1
X_ <- X[-n , -n]
# K = n.of components
K <- ncol(z)
if (K>1){m = colSums(z[-n,])} else {m = sum(z[-n])}
M <- repmat(m, K, 1)
z[-n,] %*% X_ %*% z[-n,] -
?diag
z[-n,] %*% X_ %*% z[-n,]
(X_ %*% z[-n,] * z[-n,]) / 2)
(X_ %*% z[-n,] * z[-n,]) / 2
diag((X_ %*% z[-n,] * z[-n,]) / 2)
diag(unlist((X_ %*% z[-n,] * z[-n,]) / 2))
unlist((X_ %*% z[-n,] * z[-n,]) / 2)
t((X_ %*% z[-n,] * z[-n,]) / 2)
diag(t((X_ %*% z[-n,] * z[-n,]) / 2))
matrix(diag((X_ %*% z[-n,] * z[-n,]) / 2)))
matrix(diag((X_ %*% z[-n,] * z[-n,]) / 2))
X_@z[nn,:]*z[nn,:]
X_ %*% z[-n,] * z[-n,]
colSums(X_ %*% z[-n,] * z[-n,])
colSums(X_ %*% z[-n,] * z[-n,]) / 2
diag(colSums(X_ %*% z[-n,] * z[-n,]) / 2)
diag(colSums(X_ %*% z[-n,] * z[-n,]) / 2, nrow=K)
z[-n,] %*% X_ %*% z[-n,] - diag(colSums(X_ %*% z[-n,] * z[-n,]) / 2, nrow=K)
M1 <- z[-n,] %*% X_ %*% z[-n,] - diag(colSums(X_ %*% z[-n,] * z[-n,]) / 2, nrow=K)
m
t(m)
t(m) %*% m
m*(m+1)
m*(m+1) / 2
diag(m*(m+1) / 2)
diag(m*(m+1) / 2, nrow=K)
M0 <- t(m) %*% m - diag(m*(m+1) / 2, nrow=K) - M1
M0
z[-n, ] %*% X[-n, n]
X[-n, n]
r <- z[-n,] %*% X[-n, n]
r
R <- repmat(r, K, 1)
R
?lbeta
M1+R
a <- 1
b <- 1
A <- 10
logLik <-
lbeta(M1+R+a)
logLik <-
lbeta(M1+R+a, M0+M-R+b)
lbeta
logLik <- lbeta(M1+R+a, M0+M-R+b)
logLik
M0
M
R
b
M0+M-R+b
M1+R+a
logLik <- lbeta(M1+R+a, M0+M-R+b) - lbeta(M1+a, M0+b)
logLik
logLik_n <- lbeta(r+a, m-r+b) - lbeta(a,b)
logLik_n
cbind(logLik, logLik_n)
rbind(logLik, logLik_n)
logLik_n <- lbeta(M1+R+a, M0+M-R+b) - lbeta(M1+a, M0+b)
logLik_newcomp <- lbeta(r+a, m-r+b) - lbeta(a,b)
logLikelihood <- rbind(logLik_n, logLik_newcomp)
logLikelihood
logLikelihood <- rowSums(rbind(logLik_n, logLik_newcomp))
logLikelihood
logPrior <- log(c(m,A))
logPrior
logPosterior <- logPrior + logLikelihood
logPosterior
P = exp(logPosterior - max(logPosterior))
P
unif
unif()
?unif
runif()
runif(1)
draw = runif(1)
draw
which(rmultinom(1,1,p) > 0)
which(rmultinom(1,1,P) > 0)
rmultinom
?rmultinom
cumsum(P)/sum(P)
which(draw < cumsum(P)/sum(P))
i = which(draw < cumsum(P)/sum(P))
i
z
z[n,]
z[n,] = 0
z
cbind(z, rep(0, N))
z[n,] <- 0
if (i == K+1){
z <- cbind(z, rep(0,N))
}
z[n,i] <- 1
z
z <- cbind(z, rep(0,N))
z
colSums(z)
colSums(z) > 0
colSums(z) == 0
which(colSums(z) == 0)
z <- cbind(z, rep(0,N))
which(colSums(z) == 0)
idx_empty <- which(colSums(z) == 0)
idx_empty
z[, -idx_empty]
z <- z[, -idx_empty]
z
T <- 10
Z = matrix(nrow=N, ncol=T)
Z
Z[,1]
Z[,1] <- z
z
Z = vector(length=T)
Z
Z[,1] <- z
Z = vector(mode="list" ,length=T)
Z
Z[,1] <- z
Z1] <- z
Z[1] <- z
Z
Z[1]
Z <- list()
Z
Z[1] <- z
Z
z
Z[[1]] <- z
Z
Z[[2]] <- z
Z
Z <- list()
Z[[1]] <- z
n = 2
X_ <- X[-n , -n]
# K = n.of components
K <- ncol(z)
if (K>1){m = colSums(z[-n,])} else {m = sum(z[-n])}
M <- repmat(m, K, 1)
m
M
M1 <- z[-n,] %*% X_ %*% z[-n,] - diag(colSums(X_ %*% z[-n,] * z[-n,]) / 2, nrow=K)
z[-n,]
M1 <- t(z[-n,]) %*% X_ %*% z[-n,] - diag(colSums(X_ %*% z[-n,] * z[-n,]) / 2, nrow=K)
M1
M0 <- t(m) %*% m - diag(m*(m+1) / 2, nrow=K) - M1
t(m)
m
dim(m)
dim(m) <- c(lenght(m), 1)
dim(m) <- c(length(m), 1)
m
if (K>1){m = colSums(z[-n,])} else {m = sum(z[-n])}
m
dim(m) <- c(1,length(m))
m
t(m)
M0 <- t(m) %*% m - diag(m*(m+1) / 2, nrow=K) - M1
